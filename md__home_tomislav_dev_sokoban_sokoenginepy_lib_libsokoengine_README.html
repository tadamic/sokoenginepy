<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsokoengine: libsokoengine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsokoengine
   &#160;<span id="projectnumber">0.5.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__home_tomislav_dev_sokoban_sokoenginepy_lib_libsokoengine_README.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">libsokoengine </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Sokoban and variants game engine</p>
<div class="image">
<object type="image/svg+xml" data="http://img.shields.io/badge/version-0.5.3-blue.svg" alt="Version"></object>
</div>
<p> <a href="http://en.cppreference.com/w/"></a> <a href="http://opensource.org/licenses/GPL-3.0"></a></p>
<p>C++ implementation of classic Sokoban game inspired by <a href="http://sourceforge.net/projects/sokobanyasc/">SokobanYASC</a>, <a href="https://www.sokoban-online.de/">JSoko</a> and <a href="http://webpages.dcu.ie/~tyrrelma/MazezaM/">MazezaM</a> featuring:</p>
<ul>
<li>portable, using C++11 and <a href="http://www.boost.org/">boost</a></li>
<li>supports Sokoban, Hexoban, Trioban and Octoban variants<ul>
<li>Sokoban+ for all supported variants</li>
<li>multiple pushers (Multiban) for all variants</li>
</ul>
</li>
<li>fast game engine implementation with single step undo/redo</li>
<li>Optional Python 3 bindings using <a href="https://github.com/pybind/pybind11">pybind11</a></li>
<li>TODO: self sufficient - clients are not required to link to any dependencies (not even Boost) because all compile time dependencies are either header-only or linked statically by default and also not exposed in own libsokoengine headers</li>
</ul>
<p>Full C++ API docs are available at <a href="http://tadams42.github.io/sokoenginepy/">http://tadams42.github.io/sokoenginepy/</a>. Following sections describe key concepts of library.</p>
<ul>
<li><a href="#install">Install</a></li>
<li><a href="#usage-documentation">Usage &amp; Documentation</a></li>
<li><a href="#big-picture-view">Big picture view</a><ul>
<li><a href="#game-variant">Game variant</a></li>
<li><a href="#game-boards">Game boards</a></li>
<li><a href="#game-logic-and-movement">Game logic and movement</a></li>
<li><a href="#piece-tracking-position-hashing-and-victory-conditions">Piece tracking, position hashing and victory conditions</a></li>
<li><a href="#game-snapshots-and-movement-recording">Game snapshots and movement recording</a></li>
</ul>
</li>
<li><a href="#troubleshooting-issues-and-bugs">Troubleshooting, issues and bugs</a></li>
</ul>
<h2>Install</h2>
<p>Detailed build and install instructions (including integration with your <a href="http://www.cmake.org">CMake</a> projects, etc...) are in INSTALL.md. Quick summary:</p>
<div class="fragment"><div class="line">$ git clone --recursive https://github.com/tadams42/sokoenginepy.git</div><div class="line">$ cd sokoenginepy &amp;&amp; mkdir build &amp;&amp; cd build</div><div class="line">$ cmake ../</div><div class="line">$ make &amp;&amp; make install</div></div><!-- fragment --><h2>Usage &amp; Documentation</h2>
<p>Full docs can be generated from source using <code>make docs</code> target (<a href="http://www.stack.nl/~dimitri/doxygen/">Doxygen</a> required) and are also available online at <a href="http://tadams42.github.io/sokoenginepy/">http://tadams42.github.io/sokoenginepy/</a>. Note that online docs are generated from <code>master</code> branch.</p>
<p>Minimal example <code>main.cpp</code> is:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;sokoengine.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacesokoengine.html">sokoengine</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <a class="code" href="classsokoengine_1_1HexobanBoard.html">HexobanBoard</a> b;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2>Big picture view</h2>
<p>There are few key concepts implemented by library and explained by following sections.</p>
<h3>Game variant</h3>
<p>We implement four game variants: Sokoban, Hexoban, Trioban and Octoban. These differ by plane tessellation on which game board is laid out:</p>
<ul>
<li>Sokoban boards consist of adjacent squares</li>
<li>Hexoban boards consist of adjacent hexagons</li>
<li>Trioban boards consist of adjacent triangles</li>
<li>Octoban boards consist of interchanging, adjacent octagons and squares</li>
</ul>
<p>Tessellation of game board determines available moves for game pieces. In general there are 8 supported movement directions: left, right, up, down, north west, north east, south west and south east. Of course, not all tessellations support all directions. Also, one set of directions may have different meaning in different tessellations.</p>
<p>To abstract all these differences, we implement <code>Tessellation</code> class, with subclass for each of supported variants. Instances of <code>Tessellation</code> are then used by other classes to parameterize game variant.</p>
<p>Note that <code>Tessellation</code> is low level implementation detail, and although it helps to be aware of its existence, client code doesn't usually need to interact with it directly.</p>
<h3>Game boards</h3>
<p>Game board consists of 2D grid of cells. Each cell has a state describing its board element (ie. wall, pusher, box, goal...) and can have some additional flags added to that state. These flags are not displayed but are used internally by board editors, movement logic, etc.. Board elements (cells) are implemented by <code>BoardCell</code> class.</p>
<p>Game board is implemented using <code>VariantBoard</code> base class with concrete implementations for each variant (ie. <code>SokobanBoard</code>, <code>HexobanBoard</code>, etc...). For speed efficiency, board's 2D grid can be thought of as a 1D array of <code>BoardCell</code>. This means that most methods in <code>VariantBoard</code> and in other places in library, use 1D indexes to reference individual cells. Utility functions are provided that convert 2D coordinates to 1D indexes and vice versa (ie. <code>index1d</code>).</p>
<p><code>VariantBoard</code> has following responsibilities:</p>
<ul>
<li>stores and provides reference to individual board cells</li>
<li>manages board resizing (adding/removing rows and columns) for ie. editing sessions</li>
<li>provides board-space searching capabilities like getting neighbor cell of given cell, detecting playable area of board, finding movement path between two points for either pusher or box, etc... (internally, appropriate graph structure for each tessellation and appropriate <code>Tessellation</code> are used)</li>
<li>implements <code>std::string</code> (de)serialization. Traditional format for these strings is extended to support RLE compression of them, following specification of <code>SokobanYASC</code> <code>.sok</code> format.</li>
</ul>
<p>Following is some example code for <code>VariantBoard</code> usage:</p>
<div class="fragment"><div class="line"><span class="comment">// construction from string</span></div><div class="line">HexobanBoard board(<span class="keywordtype">string</span>() +</div><div class="line">  <span class="stringliteral">&quot;---#-#-#-#----------\n&quot;</span> +</div><div class="line">  <span class="stringliteral">&quot;--#-------#---------\n&quot;</span> +</div><div class="line">  <span class="stringliteral">&quot;-#-@-----#----------\n&quot;</span> +</div><div class="line">  <span class="stringliteral">&quot;--#-$---$-#-#-#-#-#-\n&quot;</span> +</div><div class="line">  <span class="stringliteral">&quot;-#---.---.-+---$---#\n&quot;</span> +</div><div class="line">  <span class="stringliteral">&quot;--#---*-----------#-\n&quot;</span> +</div><div class="line">  <span class="stringliteral">&quot;---#-#-#-#-#-#-#-#--\n&quot;</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// editing and cell referencing</span></div><div class="line">board[42].has_pusher();</div><div class="line">board[42] = BoardCell(<span class="charliteral">&#39;@&#39;</span>);</div><div class="line"><span class="keyword">const</span> BoardCell&amp; cell = board[<a class="code" href="namespacesokoengine.html#a1e94693722ae70b0fed5b4c4b775c7f5">index_1d</a>(42, 24, board.width())];</div><div class="line"></div><div class="line"><span class="comment">// board-space searches</span></div><div class="line"><a class="code" href="namespacesokoengine.html#a9b5a7a627c89129ab507d2f504390045">position_t</a> pusher_position = 42;</div><div class="line"><a class="code" href="namespacesokoengine.html#a1823268c17463fcdea6537c2f7b566bc">Positions</a> reachable_by_pusher = board.positions_reachable_by_pusher(pusher_position);</div><div class="line">board.mark_play_area();</div><div class="line"><a class="code" href="namespacesokoengine.html#a9b5a7a627c89129ab507d2f504390045">position_t</a> neighbor = board.neighbor(42, Direction::NORTH_WEST);</div><div class="line"><a class="code" href="namespacesokoengine.html#a1823268c17463fcdea6537c2f7b566bc">Positions</a> jump_path = board.find_jump_path(42, 24);</div><div class="line"></div><div class="line"><span class="comment">// std::string serialization</span></div><div class="line"><span class="keywordtype">string</span> output = board.to_str();</div></div><!-- fragment --><h3>Game logic and movement</h3>
<p>All game variants follow exactly same game rules. From <a href="https://en.wikipedia.org/wiki/Sokoban#Rules">Wikipedia-Sokoban rules</a>, classic rules of Sokoban are:</p>
<blockquote class="doxtable">
<p>The game is played on a board of squares, where each square is a floor or a wall. Some floor squares contain boxes, and some floor squares are marked as storage locations.</p>
<p>The player is confined to the board, and may move horizontally or vertically onto empty squares (never through walls or boxes). The player can also move into a box, which pushes it into the square beyond. Boxes may not be pushed into other boxes or walls, and they cannot be pulled. The number of boxes is equal to the number of storage locations. The puzzle is solved when all boxes are at storage locations. </p>
</blockquote>
<p>Beside classic rules of games, we implement two rule additions:</p>
<ol type="1">
<li>Multiban - we allow and implement more than one pusher per board. In this situation, classic rules of game apply to each of the pushers on board with additional rule that <em>pusher can't move through another pusher</em></li>
<li>Reverse mode board solving. This is another way of playing game. When game is started, box and goal positions are switched and rules of game are slightly modified:<ul>
<li>pusher can only pull boxes, not push them</li>
<li>before first box is pulled pusher is allowed to jump to any empty board cell</li>
<li>when boxes' and goals' positions are switched, pusher may end up standing "on top" of box in which case first move for that pusher must be jump</li>
<li>jumping after first pull can be optionally enabled if that helps searching for board solution</li>
</ul>
</li>
</ol>
<p>Class responsible for implementing all movement rules is <code>Mover</code>. <code>Mover</code> instance is attached to <code>VariantBoard</code> instance and it then performs movement on it.</p>
<p>Main responsibilities of <code>Mover</code> are:</p>
<ul>
<li>implement all game rules and modes of playing</li>
<li>executes pusher and box movement on any <code>VariantBoard</code> instance</li>
<li>provides single step undo/redo</li>
<li>echoes performed moves (for movement display in rendering engines). This is especially interesting for future GUI implementations. To understand this feature better, consider following sequence of moves: <code>uuld</code> (up, up, left, down). When they are preformed, <code>Mover</code> echoes <code>uuld</code> which can be then rendered by ie. GUI. Now, let's say we want to undo them. We tell <code>Mover</code> to undo these moves and it echoes back <code>urdd</code> (up, right, down, down) which is straightforward to render in GUI. Without this feature, any rendering engine would have to actually know what undo of moves means and implement correct <code>undo</code> of performed movement making it (the rendering engine) both more complex and redundant.</li>
</ul>
<p><code>Mover</code> strives to be fast and efficient so it lacks full game features (like infinite undo/redo, tracking and exporting movement history, etc.). It is intended to be used by future full game implementations and solver implementations.</p>
<p>Examples of <code>Mover</code> use:</p>
<div class="fragment"><div class="line"><span class="comment">// Forward solving mode is default</span></div><div class="line">SokobanBoard board(42, 24);</div><div class="line">Mover mover(board);</div><div class="line"></div><div class="line"><span class="comment">// Constructing reverse mover switches box and goal positions in supplied board</span></div><div class="line">SokobanBoard board2(42, 24);</div><div class="line">Mover mover2(board2, SolvingMode::REVERSE);</div><div class="line"></div><div class="line"><span class="comment">// selecting pusher that will perform next move</span></div><div class="line">mover.select_pusher(DEFAULT_PIECE_ID);</div><div class="line">mover.select_pusher(DEFAULT_PIECE_ID + 2);</div><div class="line"></div><div class="line"><span class="comment">// Forward mode: move selected pusher right and push box if it is there</span></div><div class="line"><span class="comment">// Reverse mode: move pusher right and pull box with it if box is there</span></div><div class="line">mover.move(Direction::RIGHT);</div><div class="line"></div><div class="line"><span class="comment">// Box pulling in reverse mode can be enabled/disabled</span></div><div class="line">mover.set_pulls_boxes(<span class="keyword">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// jump selected pusher to new position</span></div><div class="line"><span class="comment">// jumps are allowed only in reverse mode and only before first box pull</span></div><div class="line">mover2.jump(42);</div><div class="line"></div><div class="line"><span class="comment">// echoing performed movement for rendering engines</span></div><div class="line"><span class="keyword">const</span> Mover::Moves&amp; moves = mover.last_move();</div><div class="line">mover.move(Direction::LEFT);</div><div class="line"><span class="comment">// moves[0].direction() == Direction::LEFT</span></div><div class="line">mover.undo_last_move();</div><div class="line"><span class="comment">// moves[0].direction() == Direction::RIGHT;</span></div></div><!-- fragment --><p><code>Mover</code> operates directly on referenced <code>VariantBoard</code> so that instance should not be edited outside of its <code>Mover</code>. For the same reason, it is not allowed to attach two movers to same game board.</p>
<h3>Piece tracking, position hashing and victory conditions</h3>
<p>To allow fast pusher and box positions retrieval and tracking, we implement cache class - <code>BoardState</code>. This class stores positions of board pieces, and allows fast update and retrieval of them.</p>
<p>On top of <code>BoardState</code> we implement <code>HashedBoardState</code>. Although <code>Mover</code> doesn't need board hashing in any way, future solver implementations will need it. <code>HashedBoardState</code> implements Zobrist hashing of current positions of pushers and boxes. This can then be used by solvers to implement and speed up game-space searches by storing visited board hashes in cache tables while performing game-space search.</p>
<p>When <code>Mover</code> is attached to <code>VariantBoard</code> it also creates fresh instance of <code>HashedBoardState</code> and keeps it up to date with current board position.</p>
<p><code>BoardState</code> also implements checking of victory conditions. There are two main groups of those:</p>
<ol type="1">
<li>Classic victory where any position in which each box is positioned on top of some goal</li>
<li>Sokoban+ victory condition where each box is positioned on top of goal with the same id as that box</li>
</ol>
<p>Sokoban+ is optional feature that can be enabled by assigning <code>boxorder</code> and <code>goalorder</code> sequences to board. When these sequences are present, new victory conditions are activated. For example, having board with five boxes, we could assign these sequences: <code>1 1 2 2 3</code> and <code>2 1 3 1 2</code>. After that, board is considered solved only when boxes with ID 1 are a pushed onto goals with ID 1 etc...</p>
<h3>Game snapshots and movement recording</h3>
<p>Each step of each pusher is recorded by instance of <code>AtomicMove</code>. Sequence of <code>AtomicMove</code> is implemented in <code>Snapshot</code>. Just like <code>VariantBoard</code>, <code>Snapshot</code> is serializable to <code>std::string</code>. Traditional snapshots string format is extended to support recording of jumps and selecting of different pushers in <code>Multiban</code> boards, again following <code>SokobanYASC</code> <code>.sok</code> format specification.</p>
<h2>Troubleshooting, issues and bugs</h2>
<p>Pull requests and issue reports are welcome and greatly appreciated. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Feb 24 2018 09:01:03 for libsokoengine by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
