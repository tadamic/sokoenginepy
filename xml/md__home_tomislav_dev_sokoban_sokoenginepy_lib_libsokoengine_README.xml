<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="md__home_tomislav_dev_sokoban_sokoenginepy_lib_libsokoengine_README" kind="page">
    <compoundname>md__home_tomislav_dev_sokoban_sokoenginepy_lib_libsokoengine_README</compoundname>
    <title>libsokoengine</title>
    <detaileddescription>
<para>Sokoban and variants game engine</para><para><image type="html" name="version-0.5.2-blue.svg"></image>
 <ulink url="http://en.cppreference.com/w/"></ulink> <ulink url="http://opensource.org/licenses/GPL-3.0"></ulink></para><para>C++ implementation of classic Sokoban game inspired by <ulink url="http://sourceforge.net/projects/sokobanyasc/">SokobanYASC</ulink>, <ulink url="http://www.sokoban-online.de/">JSoko</ulink> and <ulink url="http://webpages.dcu.ie/~tyrrelma/MazezaM/">MazezaM</ulink> featuring:</para><para><itemizedlist>
<listitem><para>portable, using C++11 and <ulink url="http://www.boost.org/">boost</ulink></para></listitem><listitem><para>supports Sokoban, Hexoban, Trioban and Octoban variants<itemizedlist>
<listitem><para>Sokoban+ for all supported variants</para></listitem><listitem><para>multiple pushers (Multiban) for all variants</para></listitem></itemizedlist>
</para></listitem><listitem><para>fast game engine implementation with single step undo/redo</para></listitem><listitem><para>Optional Python 3 bindings using <ulink url="https://github.com/pybind/pybind11">pybind11</ulink></para></listitem><listitem><para>TODO: self sufficient - clients are not required to link to any dependencies (not even Boost) because all compile time dependencies are either header-only or linked statically by default and also not exposed in own libsokoengine headers</para></listitem></itemizedlist>
</para><para>Full C++ API docs are available at <ulink url="http://tadams42.github.io/sokoenginepy/">http://tadams42.github.io/sokoenginepy/</ulink>. Following sections describe key concepts of library.</para><para><itemizedlist>
<listitem><para><ulink url="#install">Install</ulink></para></listitem><listitem><para><ulink url="#usage-documentation">Usage &amp; Documentation</ulink></para></listitem><listitem><para><ulink url="#big-picture-view">Big picture view</ulink><itemizedlist>
<listitem><para><ulink url="#game-variant">Game variant</ulink></para></listitem><listitem><para><ulink url="#game-boards">Game boards</ulink></para></listitem><listitem><para><ulink url="#game-logic-and-movement">Game logic and movement</ulink></para></listitem><listitem><para><ulink url="#piece-tracking-position-hashing-and-victory-conditions">Piece tracking, position hashing and victory conditions</ulink></para></listitem><listitem><para><ulink url="#game-snapshots-and-movement-recording">Game snapshots and movement recording</ulink></para></listitem></itemizedlist>
</para></listitem><listitem><para><ulink url="#troubleshooting-issues-and-bugs">Troubleshooting, issues and bugs</ulink></para></listitem></itemizedlist>
</para><para><heading level="2">Install</heading>
</para><para>Detailed build and install instructions (including integration with your <ulink url="http://www.cmake.org">CMake</ulink> projects, etc...) are in INSTALL.md. Quick summary:</para><para><programlisting><codeline><highlight class="normal">$<sp/>git<sp/>clone<sp/>--recursive<sp/>https://github.com/tadams42/sokoenginepy.git</highlight></codeline>
<codeline><highlight class="normal">$<sp/>cd<sp/>sokoenginepy<sp/>&amp;&amp;<sp/>mkdir<sp/>build<sp/>&amp;&amp;<sp/>cd<sp/>build</highlight></codeline>
<codeline><highlight class="normal">$<sp/>cmake<sp/>../</highlight></codeline>
<codeline><highlight class="normal">$<sp/>make<sp/>&amp;&amp;<sp/>make<sp/>install</highlight></codeline>
</programlisting></para><para><heading level="2">Usage &amp; Documentation</heading>
</para><para>Full docs can be generated from source using <computeroutput>make docs</computeroutput> target (<ulink url="http://www.stack.nl/~dimitri/doxygen/">Doxygen</ulink> required) and are also available online at <ulink url="http://tadams42.github.io/sokoenginepy/">http://tadams42.github.io/sokoenginepy/</ulink>. Note that online docs are generated from <computeroutput>master</computeroutput> branch.</para><para>Minimal example <computeroutput>main.cpp</computeroutput> is:</para><para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;sokoengine.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespacesokoengine" kindref="compound">sokoengine</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classsokoengine_1_1HexobanBoard" kindref="compound">HexobanBoard</ref><sp/>b;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><heading level="2">Big picture view</heading>
</para><para>There are few key concepts implemented by library and explained by following sections.</para><para><heading level="3">Game variant</heading>
</para><para>We implement four game variants: Sokoban, Hexoban, Trioban and Octoban. These differ by plane tessellation on which game board is laid out:</para><para><itemizedlist>
<listitem><para>Sokoban boards consist of adjacent squares</para></listitem><listitem><para>Hexoban boards consist of adjacent hexagons</para></listitem><listitem><para>Trioban boards consist of adjacent triangles</para></listitem><listitem><para>Octoban boards consist of interchanging, adjacent octagons and squares</para></listitem></itemizedlist>
</para><para>Tessellation of game board determines available moves for game pieces. In general there are 8 supported movement directions: left, right, up, down, north west, north east, south west and south east. Of course, not all tessellations support all directions. Also, one set of directions may have different meaning in different tessellations.</para><para>To abstract all these differences, we implement <computeroutput>Tessellation</computeroutput> class, with subclass for each of supported variants. Instances of <computeroutput>Tessellation</computeroutput> are then used by other classes to parameterize game variant.</para><para>Note that <computeroutput>Tessellation</computeroutput> is low level implementation detail, and although it helps to be aware of its existence, client code doesn&apos;t usually need to interact with it directly.</para><para><heading level="3">Game boards</heading>
</para><para>Game board consists of 2D grid of cells. Each cell has a state describing its board element (ie. wall, pusher, box, goal...) and can have some additional flags added to that state. These flags are not displayed but are used internally by board editors, movement logic, etc.. Board elements (cells) are implemented by <computeroutput>BoardCell</computeroutput> class.</para><para>Game board is implemented using <computeroutput>VariantBoard</computeroutput> base class with concrete implementations for each variant (ie. <computeroutput>SokobanBoard</computeroutput>, <computeroutput>HexobanBoard</computeroutput>, etc...). For speed efficiency, board&apos;s 2D grid can be thought of as a 1D array of <computeroutput>BoardCell</computeroutput>. This means that most methods in <computeroutput>VariantBoard</computeroutput> and in other places in library, use 1D indexes to reference individual cells. Utility functions are provided that convert 2D coordinates to 1D indexes and vice versa (ie. <computeroutput>index1d</computeroutput>).</para><para><computeroutput>VariantBoard</computeroutput> has following responsibilities:</para><para><itemizedlist>
<listitem><para>stores and provides reference to individual board cells</para></listitem><listitem><para>manages board resizing (adding/removing rows and columns) for ie. editing sessions</para></listitem><listitem><para>provides board-space searching capabilities like getting neighbor cell of given cell, detecting playable area of board, finding movement path between two points for either pusher or box, etc... (internally, appropriate graph structure for each tessellation and appropriate <computeroutput>Tessellation</computeroutput> are used)</para></listitem><listitem><para>implements <computeroutput>std::string</computeroutput> (de)serialization. Traditional format for these strings is extended to support RLE compression of them, following specification of <computeroutput>SokobanYASC</computeroutput> <computeroutput>.sok</computeroutput> format.</para></listitem></itemizedlist>
</para><para>Following is some example code for <computeroutput>VariantBoard</computeroutput> usage:</para><para><programlisting><codeline><highlight class="comment">//<sp/>construction<sp/>from<sp/>string</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">HexobanBoard<sp/>board(</highlight><highlight class="keywordtype">string</highlight><highlight class="normal">()<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="stringliteral">&quot;---#-#-#-#----------\n&quot;</highlight><highlight class="normal"><sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="stringliteral">&quot;--#-------#---------\n&quot;</highlight><highlight class="normal"><sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="stringliteral">&quot;-#-@-----#----------\n&quot;</highlight><highlight class="normal"><sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="stringliteral">&quot;--#-$---$-#-#-#-#-#-\n&quot;</highlight><highlight class="normal"><sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="stringliteral">&quot;-#---.---.-+---$---#\n&quot;</highlight><highlight class="normal"><sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="stringliteral">&quot;--#---*-----------#-\n&quot;</highlight><highlight class="normal"><sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="stringliteral">&quot;---#-#-#-#-#-#-#-#--\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>editing<sp/>and<sp/>cell<sp/>referencing</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">board[42].has_pusher();</highlight></codeline>
<codeline><highlight class="normal">board[42]<sp/>=<sp/>BoardCell(</highlight><highlight class="charliteral">&apos;@&apos;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>BoardCell&amp;<sp/>cell<sp/>=<sp/>board[<ref refid="namespacesokoengine_1a1e94693722ae70b0fed5b4c4b775c7f5" kindref="member">index_1d</ref>(42,<sp/>24,<sp/>board.width())];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>board-space<sp/>searches</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacesokoengine_1a9b5a7a627c89129ab507d2f504390045" kindref="member">position_t</ref><sp/>pusher_position<sp/>=<sp/>42;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacesokoengine_1a1823268c17463fcdea6537c2f7b566bc" kindref="member">Positions</ref><sp/>reachable_by_pusher<sp/>=<sp/>board.positions_reachable_by_pusher(pusher_position);</highlight></codeline>
<codeline><highlight class="normal">board.mark_play_area();</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacesokoengine_1a9b5a7a627c89129ab507d2f504390045" kindref="member">position_t</ref><sp/>neighbor<sp/>=<sp/>board.neighbor(42,<sp/>Direction::NORTH_WEST);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacesokoengine_1a1823268c17463fcdea6537c2f7b566bc" kindref="member">Positions</ref><sp/>jump_path<sp/>=<sp/>board.find_jump_path(42,<sp/>24);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>std::string<sp/>serialization</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>output<sp/>=<sp/>board.to_str();</highlight></codeline>
</programlisting></para><para><heading level="3">Game logic and movement</heading>
</para><para>All game variants follow exactly same game rules. From <ulink url="https://en.wikipedia.org/wiki/Sokoban#Rules">Wikipedia-Sokoban rules</ulink>, classic rules of Sokoban are:</para><para><blockquote><para>The game is played on a board of squares, where each square is a floor or a wall. Some floor squares contain boxes, and some floor squares are marked as storage locations.</para><para>The player is confined to the board, and may move horizontally or vertically onto empty squares (never through walls or boxes). The player can also move into a box, which pushes it into the square beyond. Boxes may not be pushed into other boxes or walls, and they cannot be pulled. The number of boxes is equal to the number of storage locations. The puzzle is solved when all boxes are at storage locations. </para></blockquote></para><para>Beside classic rules of games, we implement two rule additions:</para><para><orderedlist>
<listitem><para>Multiban - we allow and implement more than one pusher per board. In this situation, classic rules of game apply to each of the pushers on board with additional rule that <emphasis>pusher can&apos;t move through another pusher</emphasis></para></listitem><listitem><para>Reverse mode board solving. This is another way of playing game. When game is started, box and goal positions are switched and rules of game are slightly modified:<itemizedlist>
<listitem><para>pusher can only pull boxes, not push them</para></listitem><listitem><para>before first box is pulled pusher is allowed to jump to any empty board cell</para></listitem><listitem><para>when boxes&apos; and goals&apos; positions are switched, pusher may end up standing &quot;on top&quot; of box in which case first move for that pusher must be jump</para></listitem><listitem><para>jumping after first pull can be optionally enabled if that helps searching for board solution</para></listitem></itemizedlist>
</para></listitem></orderedlist>
</para><para>Class responsible for implementing all movement rules is <computeroutput>Mover</computeroutput>. <computeroutput>Mover</computeroutput> instance is attached to <computeroutput>VariantBoard</computeroutput> instance and it then performs movement on it.</para><para>Main responsibilities of <computeroutput>Mover</computeroutput> are:</para><para><itemizedlist>
<listitem><para>implement all game rules and modes of playing</para></listitem><listitem><para>executes pusher and box movement on any <computeroutput>VariantBoard</computeroutput> instance</para></listitem><listitem><para>provides single step undo/redo</para></listitem><listitem><para>echoes performed moves (for movement display in rendering engines). This is especially interesting for future GUI implementations. To understand this feature better, consider following sequence of moves: <computeroutput>uuld</computeroutput> (up, up, left, down). When they are preformed, <computeroutput>Mover</computeroutput> echoes <computeroutput>uuld</computeroutput> which can be then rendered by ie. GUI. Now, let&apos;s say we want to undo them. We tell <computeroutput>Mover</computeroutput> to undo these moves and it echoes back <computeroutput>urdd</computeroutput> (up, right, down, down) which is straightforward to render in GUI. Without this feature, any rendering engine would have to actually know what undo of moves means and implement correct <computeroutput>undo</computeroutput> of performed movement making it (the rendering engine) both more complex and redundant.</para></listitem></itemizedlist>
</para><para><computeroutput>Mover</computeroutput> strives to be fast and efficient so it lacks full game features (like infinite undo/redo, tracking and exporting movement history, etc.). It is intended to be used by future full game implementations and solver implementations.</para><para>Examples of <computeroutput>Mover</computeroutput> use:</para><para><programlisting><codeline><highlight class="comment">//<sp/>Forward<sp/>solving<sp/>mode<sp/>is<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">SokobanBoard<sp/>board(42,<sp/>24);</highlight></codeline>
<codeline><highlight class="normal">Mover<sp/>mover(board);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>reverse<sp/>mover<sp/>switches<sp/>box<sp/>and<sp/>goal<sp/>positions<sp/>in<sp/>supplied<sp/>board</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">SokobanBoard<sp/>board2(42,<sp/>24);</highlight></codeline>
<codeline><highlight class="normal">Mover<sp/>mover2(board2,<sp/>SolvingMode::REVERSE);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>selecting<sp/>pusher<sp/>that<sp/>will<sp/>perform<sp/>next<sp/>move</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">mover.select_pusher(DEFAULT_PIECE_ID);</highlight></codeline>
<codeline><highlight class="normal">mover.select_pusher(DEFAULT_PIECE_ID<sp/>+<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Forward<sp/>mode:<sp/>move<sp/>selected<sp/>pusher<sp/>right<sp/>and<sp/>push<sp/>box<sp/>if<sp/>it<sp/>is<sp/>there</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Reverse<sp/>mode:<sp/>move<sp/>pusher<sp/>right<sp/>and<sp/>pull<sp/>box<sp/>with<sp/>it<sp/>if<sp/>box<sp/>is<sp/>there</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">mover.move(Direction::RIGHT);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Box<sp/>pulling<sp/>in<sp/>reverse<sp/>mode<sp/>can<sp/>be<sp/>enabled/disabled</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">mover.set_pulls_boxes(</highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>jump<sp/>selected<sp/>pusher<sp/>to<sp/>new<sp/>position</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>jumps<sp/>are<sp/>allowed<sp/>only<sp/>in<sp/>reverse<sp/>mode<sp/>and<sp/>only<sp/>before<sp/>first<sp/>box<sp/>pull</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">mover2.jump(42);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>echoing<sp/>performed<sp/>movement<sp/>for<sp/>rendering<sp/>engines</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Mover::Moves&amp;<sp/>moves<sp/>=<sp/>mover.last_move();</highlight></codeline>
<codeline><highlight class="normal">mover.move(Direction::LEFT);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>moves[0].direction()<sp/>==<sp/>Direction::LEFT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">mover.undo_last_move();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>moves[0].direction()<sp/>==<sp/>Direction::RIGHT;</highlight></codeline>
</programlisting></para><para><computeroutput>Mover</computeroutput> operates directly on referenced <computeroutput>VariantBoard</computeroutput> so that instance should not be edited outside of its <computeroutput>Mover</computeroutput>. For the same reason, it is not allowed to attach two movers to same game board.</para><para><heading level="3">Piece tracking, position hashing and victory conditions</heading>
</para><para>To allow fast pusher and box positions retrieval and tracking, we implement cache class - <computeroutput>BoardState</computeroutput>. This class stores positions of board pieces, and allows fast update and retrieval of them.</para><para>On top of <computeroutput>BoardState</computeroutput> we implement <computeroutput>HashedBoardState</computeroutput>. Although <computeroutput>Mover</computeroutput> doesn&apos;t need board hashing in any way, future solver implementations will need it. <computeroutput>HashedBoardState</computeroutput> implements Zobrist hashing of current positions of pushers and boxes. This can then be used by solvers to implement and speed up game-space searches by storing visited board hashes in cache tables while performing game-space search.</para><para>When <computeroutput>Mover</computeroutput> is attached to <computeroutput>VariantBoard</computeroutput> it also creates fresh instance of <computeroutput>HashedBoardState</computeroutput> and keeps it up to date with current board position.</para><para><computeroutput>BoardState</computeroutput> also implements checking of victory conditions. There are two main groups of those:</para><para><orderedlist>
<listitem><para>Classic victory where any position in which each box is positioned on top of some goal</para></listitem><listitem><para>Sokoban+ victory condition where each box is positioned on top of goal with the same id as that box</para></listitem></orderedlist>
</para><para>Sokoban+ is optional feature that can be enabled by assigning <computeroutput>boxorder</computeroutput> and <computeroutput>goalorder</computeroutput> sequences to board. When these sequences are present, new victory conditions are activated. For example, having board with five boxes, we could assign these sequences: <computeroutput>1 1 2 2 3</computeroutput> and <computeroutput>2 1 3 1 2</computeroutput>. After that, board is considered solved only when boxes with ID 1 are a pushed onto goals with ID 1 etc...</para><para><heading level="3">Game snapshots and movement recording</heading>
</para><para>Each step of each pusher is recorded by instance of <computeroutput>AtomicMove</computeroutput>. Sequence of <computeroutput>AtomicMove</computeroutput> is implemented in <computeroutput>Snapshot</computeroutput>. Just like <computeroutput>VariantBoard</computeroutput>, <computeroutput>Snapshot</computeroutput> is serializable to <computeroutput>std::string</computeroutput>. Traditional snapshots string format is extended to support recording of jumps and selecting of different pushers in <computeroutput>Multiban</computeroutput> boards, again following <computeroutput>SokobanYASC</computeroutput> <computeroutput>.sok</computeroutput> format specification.</para><para><heading level="2">Troubleshooting, issues and bugs</heading>
</para><para>Pull requests and issue reports are welcome and greatly appreciated. </para>    </detaileddescription>
  </compounddef>
</doxygen>
